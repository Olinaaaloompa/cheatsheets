% -----------------------------------------------------------------------------
% Taichi cheat sheet - Released under the BSD License
% -----------------------------------------------------------------------------
\documentclass[10pt,landscape,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tabular}
\usepackage{tabularx}


% --- Page layout -------------------------------------------------------------
\usepackage[right=2.5mm, left=2.5mm, top=2.5mm, bottom=2.5mm]{geometry}

% --- English stuff -----------------------------------------------------------
\usepackage[english]{babel}
\usepackage{xspace}
\usepackage{csquotes}

% --- Graphics ----------------------------------------------------------------
\usepackage{tikz}
\usepackage{graphicx}
\usepackage[percent]{overpic}
\graphicspath{{./figures/}{./icons/}{./logos/}}
\usepackage[export]{adjustbox}

% --- Framed boxes ------------------------------------------------------------
\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{skipabove=0pt,skipbelow=0pt}
\usepackage{menukeys}

% --- URL, href and colors ----------------------------------------------------
\usepackage{xcolor}
\colorlet{citecolor}{black}
\colorlet{linkcolor}{black}
\colorlet{urlcolor}{black}
\usepackage[
  bookmarks=true,
  breaklinks=true,
  pdfborder={0 0 0},
  citecolor=citecolor,
  linkcolor=linkcolor,
  urlcolor=urlcolor,
  colorlinks=true,
  linktocpage=false,
  hyperindex=true,
  colorlinks=true,
  linktocpage=false,
  linkbordercolor=white]{hyperref}

% --- Tests -------------------------------------------------------------------
\usepackage{etoolbox}

% --- Fonts -------------------------------------------------------------------
\usepackage{fontspec}
\usepackage[fixed]{fontawesome5}
\usepackage[babel=true]{microtype}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Source Serif Pro}[
  Path           = fonts/source-serif-pro/SourceSerifPro-,
  Extension      = .otf,
  UprightFont    = Light,
  ItalicFont     = LightIt,
  BoldFont       = Regular,
  BoldItalicFont = It ]
\setsansfont{Roboto}[
  Path        = fonts/roboto/Roboto-,
  Extension   = .ttf,
  UprightFont = Light,
  ItalicFont  = LightItalic,
  BoldFont    = Regular ]
\setmonofont{Source Code Pro}[
  Path        = fonts/source-code-pro/SourceCodePro-,
  Extension   = .otf,
  UprightFont = Light,
  BoldFont    = Regular ]
\newfontfamily\RobotoCon{Roboto Condensed}[
  Path        = fonts/roboto/RobotoCondensed-,
  Extension   = .ttf,
  UprightFont = Regular,
  ItalicFont  = Italic,
  BoldFont    = Bold ]
\newfontfamily\RobotoSlab{Roboto Slab}[
  Path        = fonts/roboto-slab/RobotoSlab-,
  Extension   = .ttf,
  UprightFont = Light,
  BoldFont    = Regular ]
\newfontfamily\Roboto{Roboto}[
  Path        = fonts/roboto/Roboto-,
  Extension   = .ttf,
  UprightFont = Regular,
  ItalicFont  = Italic,
  BoldFont    = Black ]

% --- Arrays ------------------------------------------------------------------
\usepackage{multicol}
\usepackage{colortbl}
\usepackage{array, multirow}

% --- Maths -------------------------------------------------------------------
\usepackage{amsmath}


% --- PDF comments ------------------------------------------------------------
\usepackage{pdfcomment}

% --- Default options ---------------------------------------------------------
\setlength\parindent{0pt}
\setlength{\tabcolsep}{2pt}
\baselineskip=0pt
\setlength\columnsep{0.5em}


% --- Macros ------------------------------------------------------------------
\newcommand{\button}[1]{\tikz[baseline=(X.base)]
  \node [fill=orange!40, rectangle, inner sep=2pt,rounded corners=1pt] (X) {#1};}

\newcommand{\API}[1]{\tikz[baseline=(X.base)]
  \node [fill=black!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{API}}}};}

\newcommand{\READ}[1]{\tikz[baseline=(X.base)]
  \node [fill=black!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{READ}}}};}

\newcommand{\api}[1]{\tikz[baseline=(X.base)]
  \node [fill=orange!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{API}}}};}


\newcommand{\plot}[5]{%
  \begin{tabular}{@{}p{0.18\columnwidth}p{0.795\columnwidth}@{}}
    \adjustimage{width=0.18\columnwidth,valign=t}{#1} &
    {\ttfamily \scriptsize #2} \hfill \api{#3} \newline
    {\scriptsize #4}  \newline
    {\scriptsize #5 } \vspace{.7em}\\
  \end{tabular}}

\newcommand{\scale}[3]{%
  \begin{tabular}{@{}p{0.18\columnwidth}p{0.288\columnwidth}@{}}
    \adjustimage{width=0.18\columnwidth,valign=t}{#1} & {\ttfamily #2} \newline
    {\scriptsize #3}
  \end{tabular}}

\newcommand{\colormap}[1]{%
  \adjustimage{width=0.7\columnwidth,valign=c}{colormap-#1.pdf} &
  \tiny \ttfamily #1\\ \arrayrulecolor{white}\hline
}

\newcommand{\palette}[2]{%
  \adjustimage{width=0.7\columnwidth,valign=c}{colors-#1.pdf} &
  \tiny \ttfamily #2\\ \arrayrulecolor{white}\hline
}


\newcommand{\optional}[1]{\textcolor{gray}{#1}}
\newcommand{\mandatory}[1]{\textbf{#1}}
\newcommand{\parameter}[2]{%
  \expandafter\ifstrequal\expandafter{#1}{optional}%
                                     {\optional{#2}}{\mandatory{#2}}}
% --- Parameter: interpolation

\newcommand{\paramx}[1]{%
  \pdftooltip{\parameter{#1}{X}}
  {Horizontal coordinates of data point. 1D array like or scalar. }
}

\newcommand{\paramy}[1]{%
  \pdftooltip{\parameter{#1}{Y}}%
  {Vertical coordinates of data point. 1D array like or scalar. }
}

\newcommand{\paramfmt}[1]{%
  \pdftooltip{\parameter{#1}{fmt}}%
  {A format string, e.g. 'ro' for red circles. Format strings are just
   an abbreviation for quickly setting basic line properties. All of
   these and more can also be controlled by keyword arguments.}
}

\newcommand{\paramcolor}[1]{%
  \pdftooltip{\parameter{#1}{color}}%
  {Set line color.}
}

\newcommand{\parammarker}[1]{%
  \pdftooltip{\parameter{#1}{marker}}%
  {Set marker style.}
}

\newcommand{\paramlinestyle}[1]{%
  \pdftooltip{\parameter{#1}{linestyle}}%
  {Set line style.}
}


  \newcommand{\interpolation}[1]{%
  \pdftooltip{\parameter{#1}{interpolation}}
  {None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16', 'spline36',
   'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom', 'gaussian',
   'bessel', 'mitchell', 'sinc', 'lanczos'}
}

% --- Parameter: extent
\newcommand{\extent}{\pdftooltip{extent}{[left, right, bottom, top]}}

% --- Parameter: origin
\newcommand{\origin}{\pdftooltip{origin}{'upper', 'lower'}}

% --- Parameter: z
\newcommand{\Z}{\pdftooltip{z}{(M,N): an image with scalar data. The values are mappedto colors using normalization and a colormap.\textCR
(M, N, 3): an image with RGB values (0-1 float or 0-255 int)\textCR
(M, N, 4): an image with RGBA values (0-1 float or 0-255 int)}}

% --- Parameter: cmap
\newcommand{\cmap}{\pdftooltip{cmap}{
    Uniform: 'viridis', 'plasma', 'inferno', 'magma', 'cividis'\textCR
    \textCR
    Sequential: 'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
                'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
                'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn'\textCR
    \textCR
    Diverging: 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
               'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr',
               'seismic'\textCR
    \textCR
    Cyclic: 'twilight', 'twilight_shifted', 'hsv'\textCR
    \textCR
    Qualitative: 'Pastel1', 'Pastel2', 'Paired', 'Accent',
                 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10',
                 'tab20', 'tab20b', 'tab20c'}}


\newenvironment{myboxed}[1]
{\begin{mdframed}[linecolor=black,
                  backgroundcolor=white,
                  outerlinewidth=0.25pt,
                  %roundcorner=0.25em,
                  innertopmargin=1ex,
                  topline=true,
                  rightline=true,
                  leftline=true,
                  bottomline=true,
                  linecolor=black!0,
                  frametitleaboveskip=0.5em,
                  frametitlebelowskip=0.5em,
                  innerbottommargin=.5\baselineskip,
                  innerrightmargin=.5em,
                  innerleftmargin=.5em,
                  %userdefinedwidth=1\textwidth,
                  % frametitle={\scshape \bfseries \sffamily #1},
                  frametitle={\footnotesize \RobotoSlab \bfseries \hspace*{0mm} #1},
                  % frametitlerule=true,
                  %frametitlerulecolor=red,
                  frametitlebackgroundcolor=black!5,
                  frametitlerulewidth=2pt]}
{\end{mdframed}}





% -----------------------------------------------------------------------------
\begin{document}
\thispagestyle{empty}
% \footnotesize
\scriptsize

\begin{multicols*}{5}
  \begin{overpic}[width=\columnwidth,tics=6,trim=12 6 18 6, clip]{logo2.png}
    \put (16.5,1.5) {\scriptsize\RobotoCon \textcolor[HTML]{11557c}{Cheat sheet}}
    \put (80,1.5) {\tiny\Roboto \textcolor[HTML]{11557c}{Version 3.5.0}}
   \end{overpic}
  %\textbf{\Large \RobotoCon Matplotlib 3.2 cheat sheet}\\
  %{\ttfamily https://matplotlib.org} \hfill CC-BY 4.0
  % \bigskip
  \vspace{\fill}
  %\hspace{1mm} \small \url{https://matplotlib.org/}
  %\vspace{\fill}

  % --- Summary -----------------------------------------------------------
  \begin{myboxed}{Taichi in a Nutshell \hfill}
  
  \begin{itemize}
  \item A domain specific language embedded in Python for high-performance parallel computing
  \item Just-in-time (JIT) compilation
  \item Automatically parallelizes outermost for loops in a kernel
  \item Supports multiple backends (CPUs, CUDA, OpenGL, Metal...)
  \item Supports ahead-of-time compilation
  \end{itemize}
  \end{myboxed}
  \vspace{\fill}

  % --- Quick start -----------------------------------------------------------
  \begin{myboxed}{Hello, World! \hfill}

  \begin{enumerate}
  \item Install Taichi
  {\ttfamily \scriptsize
  pip install -U taichi}
  \item Verify installation - Taichi examples
  {\ttfamily \scriptsize
  ti example}
  \item Write your first Taichi program
  {\ttfamily \scriptsize
  import taichi as ti \\
  ti.init(arch=ti.cpu)}
  Note:
  \begin{itemize}
    \item A backend can be either \verb|ti.cpu| or \verb|ti.gpu|
    \item When ti.gpu is specified, Taichi moves down the backend list of \verb|ti.cuda|, \verb|ti.vulkan|, and \verb|ti.opengl/ti.metal|
    \item You can also directly pick a specific GPU backend, e.g., \verb|ti.vulkan|
  \end{itemize}
  \end{enumerate}
  \end{myboxed}
  \vspace{\fill}

  % --- Supported systems and backends --------------------------------------------------------
  \begin{myboxed}{Supported Systems and Backends}

  \begin{center}
  \begin{tabularx}{0.4\textwidth} { 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X} 
  \hline
  \textbf{platform} & \textbf{CPU}   & \textbf{CUDA} & \textbf{OpenGL} & \textbf{Metal} & \textbf{Vulkan} \\
  \hline
  Windows           & Y              & Y             &  Y              & N/A                 & Y          \\
  \hline
  Linux             & Y              & Y             &  Y              & N/A                 & Y          \\
  \hline
  MacOS             & Y              & N/A           &  N/A            & Y                   & Y          \\
  \hline
  \end{tabularx}
  \end{center}
  \end{myboxed}
  \vspace{\fill}

  % --- Data Types ---------------------------------------------------------------
  \begin{myboxed}{Data Types \hfill}

  \textbf{Primitive data types:}
    
  \verb|i8|,	\verb|i16|,	\verb|i32|,	\verb|i64|,	\verb|u8|,	\verb|u16|,	\verb|u32|,	\verb|u64|,	\verb|f16|,	\verb|f32|,	\verb|f64|
    
  \begin{tabular}{ |c|c|c| }
    \includegraphics[width=0.3\columnwidth]{i32.pdf} & \includegraphics[width=0.3\columnwidth]{u16.pfd} & \includegraphics[width=0.3\columnwidth]{f64.pdf} \\
    \end{tabular}

  \begin{itemize}
  \item Change default types:

  Default integer type: ti.i32 
  Default floating-point type: ti.f32
  To set the default integer type to ti.i64:
  {\ttfamily \scriptsize
  ti.init(default_ip=ti.i64)}
  To set the default floating-point type to ti.f64
  {\ttfamily \scriptsize
  ti.init(default_fp=ti.f64)}

  \item Explicit type casting:

  Use ti.cast():
  {\ttfamily \scriptsize
  a = 3.14 \\
  b = ti.cast(a, ti.i32)  # 3 \\
  c = ti.cast(b, ti.f32)  # 3.0}
  Use primitive types to convert a scalar variable to a different scalar type:
  {\ttfamily \scriptsize
  a = 3.14 \\
  x = int(a)    # 3 \\
  y = float(a)  # 3.14 \\
  z = ti.i32(a) # 3 \\
  w = ti.f64(a) # 3.14}

  \item Implicit type casting:
  \textit{Integer + floating point -> floating point}

  \textit{Low-precision bits + high-precision bits -> high-precision bits}

  \textit{Signed integer + unsigned integer -> unsigned integer}

  \end{itemize}

  \textbf{Compound data types:}

  \begin{itemize}
  \item Vectors and matrices:

  To create a 64-bit floating-point 4D vector type:
  {\ttfamily \scriptsize
  vec4d = ti.types.vector(4, ti.f64)}
  To create a 4x3 integer matrix type:
  {\ttfamily \scriptsize
  mat4x3i = ti.types.matrix(4, 3, int)}
  To create a vector instance v = vec4d(1, 2, 3, 4):
  {\ttfamily \scriptsize
  v = [1.0 2.0 3.0 4.0]}

  \item Structs:

  To defines a compound type for representing a sphere's center:
  {\ttfamily \scriptsize
  vec3 = ti.types.vector(3, float)}
  To defines a compound type for representing a sphere:
  {\ttfamily \scriptsize
  sphere_type = ti.types.struct(center=vec3, radius=float) \\
  sphere = sphere_type(center=vec3(0), radius=1.0)}

  \end{itemize}

  \textbf{Quantized/low-precision data types:}
  To define a 5-bit unsigned integer:
  {\ttfamily \scriptsize
  u5 = ti.types.quant.int(bits=5, signed=False)}
  To define a 10-bit signed fixed point type within the range [-20.0, 20.0]:
  {\ttfamily \scriptsize
  fixed_type_a = ti.types.quant.fixed(bits=10, max_value=20.0)}
  To define a 15-bit unsigned floating-point type with six exponent bits:
  {\ttfamily \scriptsize
  float_type_b = ti.types.quant.float(exp=6, frac=9, signed=False)}

  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Data Container ----------------------------------------------------------
  \begin{myboxed}{Data Container}
    
  \textbf{Field (global data container):}

  \begin{itemize}
  \item Declare:

  To declare a scalar field:
  {\ttfamily \scriptsize
  scalar_field = ti.field(int, shape=(640, 480))}
  To declare a vector field:
  {\ttfamily \scriptsize
  vector_field = ti.Vector.field(n=2, dtype=float, shape=(1,2,3))}
  To declare a matrix field:
  {\ttfamily \scriptsize
  matrix_field = ti.Matrix.field(n=3, m=2, dtype=float, shape=(300, 400, 500))}

  \item Access:
  {\ttfamily \scriptsize
  f_0d = ti.field(float, shape=()) \\
  f_0d[None] = 1.0 \\
  f_1d = ti.field(int, shape=10) \\
  f_1d[5] = 1 \\
  f_2d = ti.field(int, shape=(10, 10)) \\
  f_2d[1, 2] = 255 \\
  f_3d = ti.Vector.field(3, float, shape=(10, 10, 10)) \\
  f_3d[3, 3, 3] = 1, 2, 3 \\
  f_3d[3, 3, 3][0] = 1}

  \item Interact with external arrays:
  To export data in Taichi fields to NumPy arrays:
  {\ttfamily \scriptsize
  x_np = x.to_numpy()}
  To import data from NumPy arrays to Taichi fields:
  {\ttfamily \scriptsize
  x.from_numpy(x_np)}
  To export data in Taichi fields to PyTorch tensors:
  {\ttfamily \scriptsize
  x_torch = x.to_torch()}
  To import data from PyTorch tensors to Taichi fields:
  {\ttfamily \scriptsize
  x.from_torch(torch.tensor([1, 7, 3, 5]))}
  To pass a NumPy ndarray to a kernel:
  {\ttfamily \scriptsize
  @ti.kernel \\
  def numpy_as_ndarray(arr: ti.ndarray()): \\
    for i in ti.ndrange(arr.shape[0]): \\
        ...
  }

  \item Ndarray: A multidimensional container of elements of the same type and size
  {\ttfamily \scriptsize
  pos = ti.Vector.ndarray(2, ti.f32, N) \\
  vel = ti.Vector.ndarray(2, ti.f32, N) \\
  force = ti.Vector.ndarray(2, ti.f32, N)}

  \end{itemize}
  \end{myboxed}
  %
  \vspace{\fill}
  %

  % --- Kernels and functions -----------------------------------------------------------
  begin{myboxed}
  \textbf{Kernel:} An entry point where Taichi's runtime begins to take over computation tasks. The outermost for loops in a kernel are automatically parallelized.

  \textbf{Taichi function:} A building block of kernels. you can split your tasks into multiple Taichi functions to improve readability and reuse them in different kernels.

  \begin{center}
  \begin{tabularx}{\columnwidth} { 
  | >{\raggedright\arraybackslash}X 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X | }

  \hline
                  & \textbf{Taichi kernel} & \textbf{Taichi function} \\
  \hline
  Decorated with  & \verb|@ti.kernel|      & \verb|ti.func|           \\
  \hline
  Called from     & Python scope           & Taichi scope             \\
  \hline
  Type hint arguments & Required           & Recommended              \\
  \hline
  Type hint return values & Required       & Recommended              \\
  \hline
  Return type     & \begin{itemize}
    \item Scalar
    \item \verb|ti.Vector|
    \item \verb|ti.Matrix|
  \end{itemize}                            & \begin{itemize}
    \item Scalar
    \item \verb|ti.Vector|
    \item \verb|ti.Matrix|
    \item \verb|ti.Struct|
    \item ...
  \end{itemize}                                                      \\
  \hline
  Max. No. of elements in arguments & \begin{itemize}
    \item 32 (for OpenGL)
    \item 64 (for others)
  \end{itemize}                           & Unlimited                \\
  \hline
  Max. No. of return values        & 1    & Unlimited                \\
  \end{tabularx}
  \end{center}
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Operators --------------------------------------------------------
  \begin{myboxed}{Operators}
  
  \end{myboxed}
  %
  \vspace{\fill}
  %

  % --- Math ---------------------------------------------------------------
  \begin{myboxed}{Math \hfill}
  \textbf{Import Taichi’s math module:}
  {\ttfamily \scriptsize
  import taichi.math as tm}

  \textbf{The module supports the following:}
  \begin{itemize}
  \item Mathematical functions:
  
  \textit{Call mathematical functions in the Taichi scope}
  {\ttfamily \scriptsize
  @ti.kernel \\
  def test(): \\
      a = tm.vec3(1, 2, 3) \\
      x = ti.sin(a) # [0.841471, 0.909297, 0.141120] \\
      y = ti.floor(a) # [1.000000, 2.000000, 3.000000] \\
      z = ti.degrees(a) # [57.295780, 114.591560, 171.887344]}
  
  \item Small vector and matrix types:

  \textit{vec2/vec3/vec4: 2D/3D/4D floating-point vector types}
  \textit{ivec2/ivec3/ivec4: 2D/3D/4D integer vector types}
  \textit{uvec2/uvec3/uvec4: 2D/3D/4D unsigned integer vector types}
  \textit{mat2/mat3/mat4: 2D/3D/4D floating-point square matrix types}
  
  \item GLSL-standard functions:
  {\ttfamily \scriptsize
  @ti.kernel \\
  def example(): \\
    v = tm.vec3(0, 1, 2) \\
    w = tm.smoothstep(0, 1, v) \\
    w = tm.clamp(w, 0.2, 0.8) \\
    w = tm.reflect(v, tm.normalize(tm.vec3(1)))}
  
  \item Complex number operations in the form of 2D vectors:
  {\ttfamily \scriptsize
  @ti.kernel \\
  def test(): \\
    x = tm.vec2(1, 1) # Complex number 1+1j \\
    y = tm.vec2(0, 1) # Complex number 1j \\
    z = tm.cmul(x, y) # vec2(-1, 1) = -1+1j \\
    w = tm.cdiv(x, y) # vec2(2, 0) = 2+0j}

  \item Commonly used functions:

  \begin{center}
  \begin{tabularx}{\columnwidth} { 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X | }
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.acos(x)
        \item ti.asin(x)
        \item ti.atan2(x)
        \item ti.ceil(x)
        \item ti.clamp(x, xmin, xmax)
        \item ti.cos(x)
        \item ti.cross(x, y)
        \item ti.dot(x,y)
        \item ti.exp(x)
        \item ti.floor(x)
    \end{itemize}}                   & 
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.fract(x)
        \item ti.inverse(mat)
        \item ti.norm(x)
        \item ti.log(x)
        \item ti.max(x, y, ...)
        \item ti.min(x, y, ...)
        \item tm.mod(x,y)
        \item tm.normalize(x)
        \item tm.pow(x, a)
    \end{itemize}}                 & 
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.round(x)
        \item ti.sign(x)
        \item ti.sin(x)
        \item tm.smoothstep(e0, e1, x)
        \item ti.sqrt(x)
        \item tm.step(edge, x)
        \item ti.tan(x)
        \item ti.tanh(x)
        \item tm.degrees(x)
        \item tm.radians(x)
    \end{itemize}}\\
    \hline
  \end{tabularx}
  \end{center}

  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Data-oriented programming -------------------------------------------------------------
  \begin{myboxed}{Data-oriented programming \hfill}
  
  \textbf{Data-oriented class:}

  A data-oriented class is used when your data is actively updated in the Python scope (such as current time and user input events) and tracked in Taichi kernels.
  {\ttfamily \scriptsize
  @ti.data_oriented
  class TiArray: \\
      def __init__(self, n): \\
          self.x = ti.field(dtype=ti.i32, shape=n) \\
    \\
      @ti.kernel \\
      def inc(self): \\
          for i in self.x: \\
              self.x[i] += 1 \\

  a = TiArray(32) \\
  a.inc()}

  \textbf{Taichi dataclass}

  A dataclass is a wrapper of `ti.types.struct`. You can define Taichi functions as its methods and call these methods in the Taichi scope.
  {\ttfamily \scriptsize
  @ti.dataclass \\
  class Sphere: \\
      center: vec3 \\
      radius: float \\
    
      @ti.func \\
      def area(self):
          return 4 * math.pi * self.radius**2 \\
    \\
  @ti.kernel \\
  def test(): \\
      sphere = Sphere(vec3(0), radius=1.0) \\
      print(sphere.area())}

  \end{myboxed}
  % --- Visualization -----------------------------------------------------------
  \begin{myboxed}{Visualization \hfill}
  \textbf{GUI system:}
  {\ttfamily \scriptsize
  gui = ti.GUI('Window Title', (640, 360)) \\
  while not gui.get_event(ti.GUI.ESCAPE, ti.GUI.EXIT): \\
    gui.show() # Displays the window}

  \textbf{GGUI system:}
  {\ttfamily \scriptsize
  pixels = ti.Vector.field(3, float, (640, 480)) \\
  window = ti.ui.Window("Window Title", (640, 360)) \\
  canvas = window.get_canvas() \\
  \\
  while window.running: \\
      canvas.set_image(pixels) \\
      window.show()}
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Performance Tuning ---------------------------------------------------------------
  \begin{myboxed}{Performance Tuning \hfill}

  \textbf{\verb|kernel_profiler| (CPU and CUDA only):}

  To analyzes the performance of Taichi kernels
  {\ttfamily \scriptsize
  ti.init(ti.cpu, kernel_profiler=True) \\
  ti.profiler.print_kernel_profiler_info()} 

  \textbf{verb|loop_config()|:}

  To serialize the outermost for loop that immediately follows it
  {\ttfamily \scriptsize
  ti.loop_config(serialize=True)}
  To designate the number of threads on the CPU backend
  {\ttfamily \scriptsize
  ti.loop_config(parallelize=8)}
  To designate the number of threads in each block of the GPU backend
  {\ttfamily \scriptsize
  ti.loop_config(block_dim=16)}
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Debugging ---------------------------------------------------------------
  \begin{myboxed}{Debugging \hfill}

  \textbf{Activate debug mode:}
  {\ttfamily \scriptsize
  ti.init(arch=ti.cpu, debug=True)}

  \textbf{Runtime \verb|print| in Taichi scope:}
  {\ttfamily \scriptsize
  @ti.kernel \\
  def inside_taichi_scope(): \\
      x = 256 \\
      print('hello', x) #=> hello 256}
  
  \textbf{Runtime \verb|assert| in Taichi scope:}
  {\ttfamily \scriptsize
  ti.init(arch=ti.cpu, debug=True) \\
  \\
  x = ti.field(ti.f32, 128) \\
  \\
  @ti.kernel \\
  def do_sqrt_all(): \\
      for i in x: \\
          assert x[i] >= 0 \\
          x[i] = ti.sqrt(x[i])}
  
  \textbf{Compile-time \verb|ti.static_print|:}
  {\ttfamily \scriptsize
  x = ti.field(ti.f32, (2, 3)) \\
  y = 1 \\
  \\
  @ti.kernel \\
  def inside_taichi_scope(): \\
      ti.static_print(y) # => 1 \\
      ti.static_print(x.shape) # => (2, 3) \\
      ti.static_print(x.dtype) # => DataType.float32}
  
  \textbf{Compile-time \verb|ti.static_assert|:}
  {\ttfamily \scriptsize
  @ti.func \\
  def copy(dst: ti.template(), src: ti.template()): \\
      ti.static_assert(dst.shape == src.shape, "copy() needs src and dst fields to be same shape") \\
      for I in ti.grouped(src): \\
          dst[I] = src[I]}
  
  \textbf{Serial execution:}

  To serialize the program
  {\ttfamily \scriptsize
  ti.init(arch=ti.cpu, cpu_max_num_threads=1)}
  To serializes the for loop that immediately follows the line
  {\ttfamily \scriptsize
  ti.loop_config(serialize=True)}

  \textbf{Access a conciser version of traceback messages:}
  {\ttfamily \scriptsize
  import sys \\
  sys.tracebacklimit = 0}
  \end{myboxed}
  %
  \vspace{\fill}
  %

\end{multicols*}
\end{document}
