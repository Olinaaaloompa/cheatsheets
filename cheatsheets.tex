% % -----------------------------------------------------------------------------
% Taichi cheat sheet - Released under the BSD License
% -----------------------------------------------------------------------------
\documentclass[10pt,landscape,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tabular}
\usepackage{tabularx}
\usepackage{listings}


% --- Page layout -------------------------------------------------------------
\usepackage[right=2.5mm, left=2.5mm, top=2.5mm, bottom=2.5mm]{geometry}

% --- English stuff -----------------------------------------------------------
\usepackage[english]{babel}
\usepackage{xspace}
\usepackage{csquotes}

% --- Graphics ----------------------------------------------------------------
\usepackage{tikz}
\usepackage{graphicx}
\usepackage[percent]{overpic}
\graphicspath{{./figures/}{./icons/}{./logos/}}
\usepackage[export]{adjustbox}

% --- Framed boxes ------------------------------------------------------------
\usepackage[framemethod=TikZ]{mdframed}
\mdfsetup{skipabove=0pt,skipbelow=0pt}
\usepackage{menukeys}

% --- URL, href and colors ----------------------------------------------------
\usepackage{xcolor}
\colorlet{citecolor}{black}
\colorlet{linkcolor}{black}
\colorlet{urlcolor}{black}
\usepackage[
  bookmarks=true,
  breaklinks=true,
  pdfborder={0 0 0},
  citecolor=citecolor,
  linkcolor=linkcolor,
  urlcolor=urlcolor,
  colorlinks=true,
  linktocpage=false,
  hyperindex=true,
  colorlinks=true,
  linktocpage=false,
  linkbordercolor=white]{hyperref}

% --- Tests -------------------------------------------------------------------
\usepackage{etoolbox}

% --- Fonts -------------------------------------------------------------------
\usepackage{fontspec}
\usepackage[fixed]{fontawesome5}
\usepackage[babel=true]{microtype}
\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Source Serif Pro}[
  Path           = fonts/source-serif-pro/SourceSerifPro-,
  Extension      = .otf,
  UprightFont    = Light,
  ItalicFont     = LightIt,
  BoldFont       = Regular,
  BoldItalicFont = It ]
\setsansfont{Roboto}[
  Path        = fonts/roboto/Roboto-,
  Extension   = .ttf,
  UprightFont = Light,
  ItalicFont  = LightItalic,
  BoldFont    = Regular ]
\setmonofont{Source Code Pro}[
  Path        = fonts/source-code-pro/SourceCodePro-,
  Extension   = .otf,
  UprightFont = Light,
  BoldFont    = Regular ]
\newfontfamily\RobotoCon{Roboto Condensed}[
  Path        = fonts/roboto/RobotoCondensed-,
  Extension   = .ttf,
  UprightFont = Regular,
  ItalicFont  = Italic,
  BoldFont    = Bold ]
\newfontfamily\RobotoSlab{Roboto Slab}[
  Path        = fonts/roboto-slab/RobotoSlab-,
  Extension   = .ttf,
  UprightFont = Light,
  BoldFont    = Regular ]
\newfontfamily\Roboto{Roboto}[
  Path        = fonts/roboto/Roboto-,
  Extension   = .ttf,
  UprightFont = Regular,
  ItalicFont  = Italic,
  BoldFont    = Black ]

% --- Arrays ------------------------------------------------------------------
\usepackage{multicol}
\usepackage{colortbl}
\usepackage{array, multirow}

% --- Maths -------------------------------------------------------------------
\usepackage{amsmath}


% --- PDF comments ------------------------------------------------------------
\usepackage{pdfcomment}

% --- Default options ---------------------------------------------------------
\setlength\parindent{0pt}
\setlength{\tabcolsep}{2pt}
\baselineskip=0pt
\setlength\columnsep{0.5em}


% --- Macros ------------------------------------------------------------------
\newcommand{\button}[1]{\tikz[baseline=(X.base)]
  \node [fill=orange!40, rectangle, inner sep=2pt,rounded corners=1pt] (X) {#1};}

\newcommand{\API}[1]{\tikz[baseline=(X.base)]
  \node [fill=black!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{API}}}};}

\newcommand{\READ}[1]{\tikz[baseline=(X.base)]
  \node [fill=black!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{READ}}}};}

\newcommand{\api}[1]{\tikz[baseline=(X.base)]
  \node [fill=orange!40, rectangle, inner sep=2pt,rounded corners=1pt] (X)
        {\href{#1}{\color{white}{\tiny \sffamily \textbf{API}}}};}


\newcommand{\plot}[5]{%
  \begin{tabular}{@{}p{0.18\columnwidth}p{0.795\columnwidth}@{}}
    \adjustimage{width=0.18\columnwidth,valign=t}{#1} &
    {\ttfamily \scriptsize #2} \hfill \api{#3} \newline
    {\scriptsize #4}  \newline
    {\scriptsize #5 } \vspace{.7em}\\
  \end{tabular}}

\newcommand{\scale}[3]{%
  \begin{tabular}{@{}p{0.18\columnwidth}p{0.288\columnwidth}@{}}
    \adjustimage{width=0.18\columnwidth,valign=t}{#1} & {\ttfamily #2} \newline
    {\scriptsize #3}
  \end{tabular}}

\newcommand{\colormap}[1]{%
  \adjustimage{width=0.7\columnwidth,valign=c}{colormap-#1.pdf} &
  \tiny \ttfamily #1\\ \arrayrulecolor{white}\hline
}

\newcommand{\palette}[2]{%
  \adjustimage{width=0.7\columnwidth,valign=c}{colors-#1.pdf} &
  \tiny \ttfamily #2\\ \arrayrulecolor{white}\hline
}


\newcommand{\optional}[1]{\textcolor{gray}{#1}}
\newcommand{\mandatory}[1]{\textbf{#1}}
\newcommand{\parameter}[2]{%
  \expandafter\ifstrequal\expandafter{#1}{optional}%
                                     {\optional{#2}}{\mandatory{#2}}}
% --- Parameter: interpolation

\newcommand{\paramx}[1]{%
  \pdftooltip{\parameter{#1}{X}}
  {Horizontal coordinates of data point. 1D array like or scalar. }
}

\newcommand{\paramy}[1]{%
  \pdftooltip{\parameter{#1}{Y}}%
  {Vertical coordinates of data point. 1D array like or scalar. }
}

\newcommand{\paramfmt}[1]{%
  \pdftooltip{\parameter{#1}{fmt}}%
  {A format string, e.g. 'ro' for red circles. Format strings are just
   an abbreviation for quickly setting basic line properties. All of
   these and more can also be controlled by keyword arguments.}
}

\newcommand{\paramcolor}[1]{%
  \pdftooltip{\parameter{#1}{color}}%
  {Set line color.}
}

\newcommand{\parammarker}[1]{%
  \pdftooltip{\parameter{#1}{marker}}%
  {Set marker style.}
}

\newcommand{\paramlinestyle}[1]{%
  \pdftooltip{\parameter{#1}{linestyle}}%
  {Set line style.}
}


  \newcommand{\interpolation}[1]{%
  \pdftooltip{\parameter{#1}{interpolation}}
  {None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16', 'spline36',
   'hanning', 'hamming', 'hermite', 'kaiser', 'quadric', 'catrom', 'gaussian',
   'bessel', 'mitchell', 'sinc', 'lanczos'}
}

% --- Parameter: extent
\newcommand{\extent}{\pdftooltip{extent}{[left, right, bottom, top]}}

% --- Parameter: origin
\newcommand{\origin}{\pdftooltip{origin}{'upper', 'lower'}}

% --- Parameter: z
\newcommand{\Z}{\pdftooltip{z}{(M,N): an image with scalar data. The values are mappedto colors using normalization and a colormap.\textCR
(M, N, 3): an image with RGB values (0-1 float or 0-255 int)\textCR
(M, N, 4): an image with RGBA values (0-1 float or 0-255 int)}}

% --- Parameter: cmap
\newcommand{\cmap}{\pdftooltip{cmap}{
    Uniform: 'viridis', 'plasma', 'inferno', 'magma', 'cividis'\textCR
    \textCR
    Sequential: 'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
                'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
                'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn'\textCR
    \textCR
    Diverging: 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
               'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr',
               'seismic'\textCR
    \textCR
    Cyclic: 'twilight', 'twilight_shifted', 'hsv'\textCR
    \textCR
    Qualitative: 'Pastel1', 'Pastel2', 'Paired', 'Accent',
                 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10',
                 'tab20', 'tab20b', 'tab20c'}}


\newenvironment{myboxed}[1]
{\begin{mdframed}[linecolor=black,
                  backgroundcolor=white,
                  outerlinewidth=0.25pt,
                  %roundcorner=0.25em,
                  innertopmargin=1ex,
                  topline=true,
                  rightline=true,
                  leftline=true,
                  bottomline=true,
                  linecolor=black!0,
                  frametitleaboveskip=0.5em,
                  frametitlebelowskip=0.5em,
                  innerbottommargin=.5\baselineskip,
                  innerrightmargin=.5em,
                  innerleftmargin=.5em,
                  %userdefinedwidth=1\textwidth,
                  % frametitle={\scshape \bfseries \sffamily #1},
                  frametitle={\footnotesize \RobotoSlab \bfseries \hspace*{0mm} #1},
                  % frametitlerule=true,
                  %frametitlerulecolor=red,
                  frametitlebackgroundcolor=black!5,
                  frametitlerulewidth=2pt]}
{\end{mdframed}}





% -----------------------------------------------------------------------------
\begin{document}
\thispagestyle{empty}
% \footnotesize
\scriptsize

\begin{multicols*}{5}
  \begin{overpic}[width=\columnwidth,tics=6,trim=12 6 18 6, clip]{logo2.png}
    \put (16.5,1.5) {\scriptsize\RobotoCon \textcolor[HTML]{11557c}{Cheat sheet}}
    \put (80,1.5) {\tiny\Roboto \textcolor[HTML]{11557c}{Version 3.5.0}}
   \end{overpic}
  %\textbf{\Large \RobotoCon Matplotlib 3.2 cheat sheet}\\
  %{\ttfamily https://matplotlib.org} \hfill CC-BY 4.0
  % \bigskip
  \vspace{\fill}
  %\hspace{1mm} \small \url{https://matplotlib.org/}
  %\vspace{\fill}

  % --- Summary -----------------------------------------------------------
  \begin{myboxed}{Taichi in a Nutshell}
  
  \begin{itemize}
  \item A domain specific language embedded in Python for high-performance parallel computing
  \item Just-in-time (JIT) compilation
  \item Automatically parallelizes outermost for loops in a kernel
  \item Supports multiple backends (CPUs, CUDA, OpenGL, Metal...)
  \item Supports ahead-of-time compilation
  \end{itemize}
  \end{myboxed}
  \vspace{\fill}

  % --- Quick start -----------------------------------------------------------
  \begin{myboxed}{Hello, World!}

  \begin{enumerate}
  \item Install Taichi
  \begin{lstlisting}
  pip install -U taichi
  \end{lstlisting}
  \item Verify installation - Taichi examples
  \begin{lstlisting}
  ti example
  \end{lstlisting}
  \item Write your first Taichi program
 \begin{lstlisting}[language=Python]
  import taichi as ti
  ti.init(arch=ti.cpu)
  \end{lstlisting}
  Note:
  \begin{itemize}
    \item A backend can be either \verb|ti.cpu| or \verb|ti.gpu|
    \item When ti.gpu is specified, Taichi moves down the backend list of \verb|ti.cuda|, \verb|ti.vulkan|, and \verb|ti.opengl/ti.metal|
    \item You can also directly pick a specific GPU backend, e.g., \verb|ti.vulkan|
  \end{itemize}
  \end{enumerate}
  \end{myboxed}
  \vspace{\fill}

  % --- Supported systems and backends --------------------------------------------------------
  \begin{myboxed}{Supported Systems and Backends}

  \begin{center}
  \begin{tabularx}{0.4\textwidth} { 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X
    | >{\centering\arraybackslash}X} 
  \hline
  \textbf{platform} & \textbf{CPU}   & \textbf{CUDA} & \textbf{OpenGL} & \textbf{Metal} & \textbf{Vulkan} \\
  \hline
  Windows           & Y              & Y             &  Y              & N/A                 & Y          \\
  \hline
  Linux             & Y              & Y             &  Y              & N/A                 & Y          \\
  \hline
  MacOS             & Y              & N/A           &  N/A            & Y                   & Y          \\
  \hline
  \end{tabularx}
  \end{center}
  \end{myboxed}
  \vspace{\fill}

  % --- Data Types ---------------------------------------------------------------
  \begin{myboxed}{Data Types}

  \textbf{Primitive data types:}
    
  \verb|i8|,	\verb|i16|,	\verb|i32|,	\verb|i64|,	\verb|u8|,	\verb|u16|,	\verb|u32|,	\verb|u64|,	\verb|f16|,	\verb|f32|,	\verb|f64|
    
  \begin{tabular}{ |c|c|c| }
    \includegraphics[width=0.3\columnwidth]{i32.pdf} &  & \includegraphics[width=0.3\columnwidth]{f64.pdf} \\
    \end{tabular}

  \begin{itemize}
  \item Change default types:

  Default integer type: ti.i32 
  Default floating-point type: ti.f32
  To set the default integer type to ti.i64:
  \begin{lstlisting}[language=Python]
  ti.init(default_ip=ti.i64)
  \end{lstlisting}
  To set the default floating-point type to ti.f64
  \begin{lstlisting}[language=Python]
  ti.init(default_fp=ti.f64)
  \end{lstlisting}

  \item Explicit type casting:

  Use ti.cast():
  \begin{lstlisting}[language=Python]
  a = 3.14 
  b = ti.cast(a, ti.i32)  # 3
  c = ti.cast(b, ti.f32)  # 3.0
  \end{lstlisting}
  Use primitive types to convert a scalar variable to a different scalar type:
  \begin{lstlisting}[language=Python]
  a = 3.14
  x = int(a)    # 3
  y = float(a)  # 3.14
  z = ti.i32(a) # 3
  w = ti.f64(a) # 3.14
  \end{lstlisting}

  \item Implicit type casting:
  \textit{Integer + floating point -> floating point}

  \textit{Low-precision bits + high-precision bits -> high-precision bits}

  \textit{Signed integer + unsigned integer -> unsigned integer}

  \end{itemize}

  \textbf{Compound data types:}

  \begin{itemize}
  \item Vectors and matrices:

  To create a 64-bit floating-point 4D vector type:
  \begin{lstlisting}[language=Python]
  vec4d = ti.types.vector(4, ti.f64)
  \end{lstliting}
  To create a 4x3 integer matrix type:
  \begin{lstlisting}[language=Python]
  mat4x3i = ti.types.matrix(4, 3, int)
  \end{lstliting}
  To create a vector instance v = vec4d(1, 2, 3, 4):
 \begin{lstlisting}[language=Python]
  v = [1.0 2.0 3.0 4.0]
  \end{lstlisting}

  \item Structs:

  To defines a compound type for representing a sphere's center:
  \begin{lstlisting}[language=Python]
  vec3 = ti.types.vector(3, float)
  \end{lstlisting}
  To defines a compound type for representing a sphere:
  \begin{lstlisting}[language=Python]
  sphere_type = ti.types.struct(center=vec3, radius=float)
  sphere = sphere_type(center=vec3(0), radius=1.0)
  \end{lstlisting}

  \end{itemize}

  \textbf{Quantized/low-precision data types:}
  To define a 5-bit unsigned integer:
   \begin{lstlisting}[language=Python]
   u5 = ti.types.quant.int(bits=5, signed=False)
   \end{lstlisting}
  To define a 10-bit signed fixed point type within the range [-20.0, 20.0]:
  \begin{lstlisting}[language=Python]
  fixed_type_a = ti.types.quant.fixed(bits=10, max_value=20.0)
  \end{lstlisting}
  To define a 15-bit unsigned floating-point type with six exponent bits:
   \begin{lstlisting}[language=Python]
  float_type_b = ti.types.quant.float(exp=6, frac=9, signed=False)
  \end{lstlisting}
  

  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Data Container ----------------------------------------------------------
  \begin{myboxed}{Data Container}
    
  \textbf{Field (global data container):}

  \begin{itemize}
  \item Declare:

  To declare a scalar field:
  \begin{lstlisting}[language=Python]
  scalar_field = ti.field(int, shape=(640, 480))
  \end{lstlisting}
  To declare a vector field:
  \begin{lstlisting}[language=Python]
  vector_field = ti.Vector.field(n=2, dtype=float, shape=(1,2,3))
  \end{lstlisting}
  To declare a matrix field:
  \begin{lstlisting}[language=Python]
  matrix_field = ti.Matrix.field(n=3, m=2, dtype=float, shape=(300, 400, 500))
  \end{lstlisting}

  \item Access:
  \begin{lstlisting}[language=Python]
  f_0d = ti.field(float, shape=())
  f_0d[None] = 1.0
  f_1d = ti.field(int, shape=10)
  f_1d[5] = 1
  f_2d = ti.field(int, shape=(10, 10))
  f_2d[1, 2] = 255
  f_3d = ti.Vector.field(3, float, shape=(10, 10, 10))
  f_3d[3, 3, 3] = 1, 2, 3
  f_3d[3, 3, 3][0] = 1
  \end{lstlisting}

  \item Interact with external arrays:
  To export data in Taichi fields to NumPy arrays:
  \begin{lstlisting}[language=Python]
  x_np = x.to_numpy()
  \end{lstlisting}
  To import data from NumPy arrays to Taichi fields:
  \begin{lstlisting}[language=Python]
  x.from_numpy(x_np)
  \end{lstlisting}
  To export data in Taichi fields to PyTorch tensors:
  \begin{lstlisting}[language=Python]
  x_torch = x.to_torch()
  \end{lstlisting}
  To import data from PyTorch tensors to Taichi fields:
  \begin{lstlisting}[language=Python]
  x.from_torch(torch.tensor([1, 7, 3, 5]))
  \end{lstlisting}
  To pass a NumPy ndarray to a kernel:
  \begin{lstlisting}[language=Python]
  @ti.kernel
  def numpy_as_ndarray(arr: ti.ndarray()):
    for i in ti.ndrange(arr.shape[0]):
        ...
  \end{lstlisting}

  \item Ndarray: A multidimensional container of elements of the same type and size
  \begin{lstlisting}[language=Python]
  pos = ti.Vector.ndarray(2, ti.f32, N)
  vel = ti.Vector.ndarray(2, ti.f32, N)
  force = ti.Vector.ndarray(2, ti.f32, N)
  \end{lstlisting}

  \end{itemize}
  \end{myboxed}
  %
  \vspace{\fill}
  %

  % --- Kernels and functions -----------------------------------------------------------
  \begin{myboxed}{Kernels and Functions}
  \textbf{Kernel:} An entry point where Taichi's runtime begins to take over computation tasks. The outermost for loops in a kernel are automatically parallelized.

  \textbf{Taichi function:} A building block of kernels. you can split your tasks into multiple Taichi functions to improve readability and reuse them in different kernels.

  \begin{center}
  \begin{tabularx}{\columnwidth} { 
  | >{\raggedright\arraybackslash}X 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X | }

  \hline
                  & \textbf{Taichi kernel} & \textbf{Taichi function} \\
  \hline
  Decorated with  & \verb|@ti.kernel|      & \verb|ti.func|           \\
  \hline
  Called from     & Python scope           & Taichi scope             \\
  \hline
  Type hint arguments & Required           & Recommended              \\
  \hline
  Type hint return values & Required       & Recommended              \\
  \hline
  Return type     & \begin{itemize}
    \item Scalar
    \item \verb|ti.Vector|
    \item \verb|ti.Matrix|
  \end{itemize}                            & \begin{itemize}
    \item Scalar
    \item \verb|ti.Vector|
    \item \verb|ti.Matrix|
    \item \verb|ti.Struct|
    \item ...
  \end{itemize}                                                      \\
  \hline
  Max. No. of elements in arguments & \begin{itemize}
    \item 32 (for OpenGL)
    \item 64 (for others)
  \end{itemize}                           & Unlimited                \\
  \hline
  Max. No. of return values        & 1    & Unlimited                \\
  \end{tabularx}
  \end{center}
  
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Operators --------------------------------------------------------
  \begin{myboxed}{Operators}
  
  \end{myboxed}
  %
  \vspace{\fill}
  %

  % --- Math ---------------------------------------------------------------
  \begin{myboxed}{Math}
  \textbf{Import Taichiâ€™s math module:}
  \begin{lstlisting}[language=Python]
  import taichi.math as tm
  \end{lstlisting}

  \textbf{The module supports the following:}
  \begin{itemize}
  \item Mathematical functions:
  
  \textit{Call mathematical functions in the Taichi scope}
  \begin{lstlisting}[language=Python]
  @ti.kernel
  def test():
      a = tm.vec3(1, 2, 3)
      x = ti.sin(a) # [0.841471, 0.909297, 0.141120]
      y = ti.floor(a) # [1.000000, 2.000000, 3.000000]
      z = ti.degrees(a) # [57.295780, 114.591560, 171.887344]
  \end{lstlisting}
  
  \item Small vector and matrix types:

  \textit{vec2/vec3/vec4: 2D/3D/4D floating-point vector types}
  \textit{ivec2/ivec3/ivec4: 2D/3D/4D integer vector types}
  \textit{uvec2/uvec3/uvec4: 2D/3D/4D unsigned integer vector types}
  \textit{mat2/mat3/mat4: 2D/3D/4D floating-point square matrix types}
  
  \item GLSL-standard functions:
  \begin{lstlisting}[language=Python]
  @ti.kernel
  def example():
    v = tm.vec3(0, 1, 2)
    w = tm.smoothstep(0, 1, v)
    w = tm.clamp(w, 0.2, 0.8)
    w = tm.reflect(v, tm.normalize(tm.vec3(1)))
  \end{lstlisting}
  
  \item Complex number operations in the form of 2D vectors:
  \begin{lstlisting}[language=Python]
  @ti.kernel
  def test():
    x = tm.vec2(1, 1) # Complex number 1+1j
    y = tm.vec2(0, 1) # Complex number 1j
    z = tm.cmul(x, y) # vec2(-1, 1) = -1+1j
    w = tm.cdiv(x, y) # vec2(2, 0) = 2+0j
  \end{lstlisting}

  \item Commonly used functions:

  \begin{center}
  \begin{tabularx}{\columnwidth} { 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X 
    | >{\centering\arraybackslash}X | }
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.acos(x)
        \item ti.asin(x)
        \item ti.atan2(x)
        \item ti.ceil(x)
        \item ti.clamp(x, xmin, xmax)
        \item ti.cos(x)
        \item ti.cross(x, y)
        \item ti.dot(x,y)
        \item ti.exp(x)
        \item ti.floor(x)
    \end{itemize}}                   & 
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.fract(x)
        \item ti.inverse(mat)
        \item ti.norm(x)
        \item ti.log(x)
        \item ti.max(x, y, ...)
        \item ti.min(x, y, ...)
        \item tm.mod(x,y)
        \item tm.normalize(x)
        \item tm.pow(x, a)
    \end{itemize}}                 & 
    {\ttfamily \scriptsize
    \begin{itemize}
        \item ti.round(x)
        \item ti.sign(x)
        \item ti.sin(x)
        \item tm.smoothstep(e0, e1, x)
        \item ti.sqrt(x)
        \item tm.step(edge, x)
        \item ti.tan(x)
        \item ti.tanh(x)
        \item tm.degrees(x)
        \item tm.radians(x)
    \end{itemize}}\\
    \hline
  \end{tabularx}
  \end{center}
  
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Data-oriented programming -------------------------------------------------------------
  \begin{myboxed}{Data-oriented programming}
  
  \textbf{Data-oriented class:}

  A data-oriented class is used when your data is actively updated in the Python scope (such as current time and user input events) and tracked in Taichi kernels.
  \begin{lstlisting}[language=Python]
  @ti.data_oriented
  class TiArray:
      def __init__(self, n):
          self.x = ti.field(dtype=ti.i32, shape=n)
  
      @ti.kernel
      def inc(self):
          for i in self.x:
              self.x[i] += 1

  a = TiArray(32)
  a.inc()
  \end{lstlisting}

  \textbf{Taichi dataclass}

  A dataclass is a wrapper of `ti.types.struct`. You can define Taichi functions as its methods and call these methods in the Taichi scope.
  \begin{lstlisting}[language=Python]
  @ti.dataclass
  class Sphere:
      center: vec3
      radius: float
    
      @ti.func
      def area(self):
          return 4 * math.pi * self.radius**2
   
  @ti.kernel
  def test():
      sphere = Sphere(vec3(0), radius=1.0)
      print(sphere.area())
  \end{lstlisting}
  \end{myboxed}
  % --- Visualization -----------------------------------------------------------
  \begin{myboxed}{Visualization \hfill}
  \textbf{GUI system:}
  \begin{lstlisting}[language=Python]
  gui = ti.GUI('Window Title', (640, 360))
  while not gui.get_event(ti.GUI.ESCAPE, ti.GUI.EXIT):
    gui.show() # Displays the window
  \end{lstlisting}

  \textbf{GGUI system:}
  \begin{lstlisting}[language=Python]
  pixels = ti.Vector.field(3, float, (640, 480))
  window = ti.ui.Window("Window Title", (640, 360))
  canvas = window.get_canvas()
 
  while window.running:
      canvas.set_image(pixels)
      window.show()
  \end{lstlisting}
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Performance Tuning ---------------------------------------------------------------
  \begin{myboxed}{Performance Tuning}

  \textbf{Kernel profiler (CPU and CUDA only):}

  To analyzes the performance of Taichi kernels
  \begin{lstlisting}[language=Python]
  ti.init(ti.cpu, kernel_profiler=True)
  ti.profiler.print_kernel_profiler_info()
  \end{lstlisting}

  \textbf{Configure loops:}

  To serialize the outermost for loop that immediately follows it
  \begin{lstlisting}[language=Python]
  ti.loop_config(serialize=True)
  \end{lstlisting}
  To designate the number of threads on the CPU backend
  \begin{lstlisting}[language=Python]
  ti.loop_config(parallelize=8)
  \end{lstlisting}
  To designate the number of threads in each block of the GPU backend
  \begin{lstlisting}[language=Python]
  ti.loop_config(block_dim=16)
  \end{lstlisting}
  \end{myboxed}
  %
  \vspace{\fill}
  %
  % --- Debugging ---------------------------------------------------------------
  \begin{myboxed}{Debugging}

  \textbf{Activate debug mode:}
  {\ttfamily \scriptsize
  ti.init(arch=ti.cpu, debug=True)}

  \textbf{Runtime print in Taichi scope:}
  \begin{lstlisting}[language=Python]
  @ti.kernel
  def inside_taichi_scope():
      x = 256
      print('hello', x) #=> hello 256
  \end{lstlisting}
  
  \textbf{Runtime assert in Taichi scope:}
  \begin{lstlisting}[language=Python]
  ti.init(arch=ti.cpu, debug=True)
 
  x = ti.field(ti.f32, 128)
 
  @ti.kernel
  def do_sqrt_all():
      for i in x:
          assert x[i] >= 0
          x[i] = ti.sqrt(x[i])
  \end{lstlisting}
  
  \textbf{Compile-time static-print:}
  \begin{lstlisting}[language=Python]
  x = ti.field(ti.f32, (2, 3))
  y = 1
 
  @ti.kernel
  def inside_taichi_scope():
      ti.static_print(y) # => 1
      ti.static_print(x.shape) # => (2, 3)
      ti.static_print(x.dtype) # => DataType.float32
  \end{lstlisting}
  
  \textbf{Compile-time static-assert|:}
  \begin{lstlisting}[language=Python]
  @ti.func
  def copy(dst: ti.template(), src: ti.template()):
      ti.static_assert(dst.shape == src.shape, "copy() needs src and dst fields to be same shape")
      for I in ti.grouped(src):
          dst[I] = src[I]
  \end{lstlisting}
  
  \textbf{Serial execution:}

  To serialize the program
  \begin{lstlisting}[language=Python]
  ti.init(arch=ti.cpu, cpu_max_num_threads=1)
  \end{lstlisting}
  To serializes the for loop that immediately follows the line
  \begin{lstlisting}[language=Python]
  ti.loop_config(serialize=True)
  \end{lstlisting}

  \textbf{Access a conciser version of traceback messages:}
  \begin{lstlisting}[language=Python]
  import sys
  sys.tracebacklimit = 0
  \end{lstlisting}
  \end{myboxed}
  %
  \vspace{\fill}
  %
% ---------------------------------------------------------------------
\end{multicols*}

\end{document}
